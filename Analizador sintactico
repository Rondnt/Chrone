import pandas as pd

class node_stack:
  def __init__(self, symbol, lexeme):
    global count
    self.symbol = symbol
    self.lexeme = lexeme
    self.id = count + 1
    count += 1

class node_tree:
  def __init__(self, id, symbol, lexeme):
    self.id = id
    self.symbol = symbol
    self.lexeme = lexeme
    self.children = []
    self.father = None

def buscar_node(id, node):
    if node.id == id:
        return node
    for child in node.children:
        result = buscar_node(id, child)
        if result:
            return result
    return None
#Cargar tabla CSV
tabla = pd.read_csv("tabla.csv", index_col = 0)
count = 0
stack = []

# inicializar pila
symbol_E = node_stack('E', None)
symbol_dollar = node_stack('$', None)
stack.append(symbol_dollar)
stack.append(symbol_E)

# inicializar arbol 
root = node_tree(symbol_E.id, symbol_E.symbol, symbol_E.lexeme)

input = [
    {"symbol": "int", "lexeme": "4", "nroline": 2, "col": 2},
    {"symbol": "*", "lexeme": "*", "nroline": 2, "col": 4},
    {"symbol": "int", "lexeme": "5", "nroline": 2, "col": 6},
    {"symbol": "$", "lexeme": "$", "nroline": 0, "col": 0},
   #{"symbol": "int", "lexeme": "4", "nroline": 2, "col": 2},
   #{"symbol": "*", "lexeme": "*", "nroline": 2, "col": 4},
   #{"symbol": "(", "lexeme": "(", "nroline": 2, "col": 6},
   #{"symbol": "int", "lexeme": "5", "nroline": 2, "col": 8},
   #{"symbol": "+", "lexeme": "*", "nroline": 2, "col": 10},
   #{"symbol": "int", "lexeme": "6", "nroline": 2, "col": 12},
   #{"symbol": ")", "lexeme": ")", "nroline": 2, "col": 14},
   #{"symbol": "$", "lexeme": "$", "nroline": 0, "col": 0},
  
]

# Mantener un registro de la cadena procesada como una lista
cadena_procesada_list = []

# Función para obtener la producción de la tabla de análisis sintáctico
def obtener_produccion(terminal, no_terminal):
    try:
        return tabla.loc[no_terminal, terminal]
    except KeyError:
        return None

# Función para imprimir el árbol sintáctico
def imprimir_arbol(node, nivel=0):
    if node:
        print("  " * nivel + node.symbol)
        for child in node.children:
            imprimir_arbol(child, nivel + 1)

# Analizador sintáctico LL(1)
while stack:
    # Obtener el símbolo superior de la pila y el símbolo de entrada actual
    top_of_stack = stack[-1]
    current_input = input[0]

    if top_of_stack.symbol == current_input["symbol"]:
        # Coincidencia, avanzar en la pila y la entrada
        stack.pop()
        input.pop(0)
        cadena_procesada_list.append(current_input["lexeme"])
        # Solo agregar cuando haya coincidencia
    else:
        # Obtener la producción desde la tabla de análisis sintáctico
        production = obtener_produccion(current_input["symbol"], top_of_stack.symbol)

        if production is None:
            print("Cadena no aceptada")
            break

        # Reemplazar la producción en la pila
        stack.pop()
        production_symbols = production.split()
        production_symbols.reverse()
        for symbol in production_symbols:
            if symbol != 'e':
                new_node = NodeStack(symbol, current_input["lexeme"])
                stack.append(new_node)

                # Crear el nodo en el árbol sintáctico
                new_node_tree = NodeTree(new_node.id, new_node.symbol, new_node.lexeme)
                father = buscar_node(top_of_stack.id, root)
                father.children.append(new_node_tree)
                new_node_tree.father = father

# Si la pila está vacía y la entrada también, la cadena es aceptada
if not stack and not input:
    cadena_procesada_str = " ".join(cadena_procesada_list)
    print("Cadena procesada:", cadena_procesada_str)
    print("La cadena si es aceptada")
elif stack or input:
    print("La cadena no es aceptada")

# Imprimir el árbol sintáctico si es aceptada
if not stack and not input:
    print("Árbol sintáctico:")
    imprimir_arbol(root)
